#! /bin/bash

# build the string
oldIFS = $IFS
for f in $(ls */*.go | grep -v _test.go)
do
  if [ -f $f ] ; then
    s=$(cat $f | grep -B1 'Endpoint =')
    if [[ -n "$s" ]] ; then
      #s=${s//\`/\"}           # replace all instances of tick mark with double quotes
      #s=${s//--/}             # remove the double dashes the cat put in sometimes
      
      #s=${s//\/\//|}          # convert all remaining // to new lines to '|' as a delimeter
      s=${s//$'\n'/|}         # convert all new lines to '|'
      #s=${s//$'\t'/""}        # removes tabs
      #s=$(sed 's/||*/|/g' <<< $s) # replaces multiple new line delimeters (|) in a row to a single one
      s=$(sed 's/|  */|/g' <<< $s)  # remove spaces after each line delimeter

      IFS='|' read -r -a array <<< "$s"
      for element in "${array[@]}"; do
        # if line starts with // grab it for description
        if [[ $element == //* ]] ; then
          desc="${element}"
          desc=${desc/\/\/ /""}         # strips the // from the comment line
          #echo -e "$desc"
        fi

        # if line starts with any letter or number, it's the name and the endpoint
        if [[ $element =~ ^[a-zA-Z0-9].* ]] ; then
          prevIFS=$IFS
          IFS='=' read -r -a arr2 <<< "$element"
          name=${arr2[0]}
          endpoint=${arr2[1]}
          IFS=$prevIFS
        fi

      done
      echo -e "desc: $desc"
      echo -e "name: $name"
      echo -e "ep:   $endpoint"

      echo "------"
    fi
  fi
done
IFS=$oldIFS

